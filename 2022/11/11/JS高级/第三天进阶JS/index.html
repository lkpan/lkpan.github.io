<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta name="keywords" content="hexo, autumn" />
    <title>
        跑路博客
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/favicon.ico" />
     
<link rel="stylesheet" href="/css/style.css">


    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" />
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>

    <script>
        infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/" class="logo">
                跑路博客
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/" class="logo">
            跑路博客
        </a>
    </h1>
    <h2 class="desc">
        工地荔枝转行
    </h2>

    <div class="links">
        <ul>
            
            <li>
                <a target="_blank" rel="noopener" href="https://github.com/FrontendSophie">
                    Github
                </a>
            </li>
            
            <li>
                <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/frontendsophie/">
                    LinkedIn
                </a>
            </li>
            
        </ul>
    </div>
</header>
        <main class="main">
            <article class="post">
    
    
    
    <h2 class="post-title">
        JavaScript进阶第二天
    </h2>
    <ul class="post-date">
        <li>
            2022-11-11
        </li>
        <li>
            panmou
        </li>
    </ul>
    <div class="post-content">
        <h2 id="每个构造函数都有一个原型对象"><a href="#每个构造函数都有一个原型对象" class="headerlink" title="每个构造函数都有一个原型对象"></a>每个构造函数都有一个原型对象</h2><p>原型可以共享一个方法，把不变的方法写到prototype对象上</p>
<h2 id="构造函数this指向问题"><a href="#构造函数this指向问题" class="headerlink" title="构造函数this指向问题"></a>构造函数this指向问题</h2><pre><code>let that
function Star(uname) &#123;
that = this
console.log(this)
this.uname = uname
    &#125;
    //结果为（that === ldh）
    //Star &#123;uname: &#39;刘德华&#39;&#125;  里面this结果
</code></pre>
<p>原型实例对象里面的this指向的也是其调用者</p>
<h2 id="原型对象-prototype"><a href="#原型对象-prototype" class="headerlink" title="原型对象  .prototype"></a>原型对象  .prototype</h2><p>是个对象，可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</p>
<h2 id="constructor作用"><a href="#constructor作用" class="headerlink" title="constructor作用"></a>constructor作用</h2><p>因为使用直接&#x3D; 的形式将会使其找不到原先的构造函数，需要construtor重新指向原来的构造函数</p>
<pre><code>实例对象.constructor指向构造函数Star
Woman.prototype.constructor = Woman
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Star.prototype = &#123;</span><br><span class="line">// 从新指回创造这个原型对象的 构造函数</span><br><span class="line">      constructor: Star,</span><br><span class="line">      sing: function () &#123;</span><br><span class="line">        console.log(&#x27;唱歌&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      dance: function () &#123;</span><br><span class="line">        console.log(&#x27;跳舞&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象模型-proto"><a href="#对象模型-proto" class="headerlink" title="对象模型__proto__"></a>对象模型__proto__</h2><pre><code>__proto__与[[prototype]]一个意思
function Star (uname) &#123;
      this.name = uname
    &#125;
    let sb = new Star(&#39;sb&#39;)
    console.log(sb.__proto__ === Star.prototype);//true
    //Star：构造函数，sb实例对象，sb.__proto__ 以及Star.prototype都指向Star的原型对象
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A as 构造函数</span><br><span class="line">A-&gt;&gt;C: new一个再 .prototype</span><br><span class="line">participant B as 实例对象</span><br><span class="line">participant C as 原型对象</span><br><span class="line">A-&gt;&gt;B: new一个就可以产生实例对象</span><br><span class="line">B-&gt;&gt;C: 实例对象.__proto__</span><br><span class="line">B-&gt;&gt;A: 实例对象.__proto__.constructor</span><br><span class="line">C-&gt;&gt;A: 原型即 prototype.constructor</span><br></pre></td></tr></table></figure>

<h2 id="原型继承-公共属性"><a href="#原型继承-公共属性" class="headerlink" title="原型继承 公共属性"></a>原型继承 公共属性</h2><p>需要公共属性一致，但不是同一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Person = &#123;</span><br><span class="line">      eays : 2,</span><br><span class="line">      hand : 1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Woman() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Woman.prototype = Person</span><br><span class="line">    Woman.prototype.constructor = Woman</span><br><span class="line">    Woman.prototype.baby = &#x27;sb&#x27;</span><br><span class="line">    console.log(Woman.prototype);</span><br><span class="line">    </span><br><span class="line">    function Man () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Man.prototype = Person</span><br><span class="line">    Man.prototype.constructor = Man</span><br><span class="line">    console.log(Man.prototype);</span><br><span class="line">    </span><br><span class="line">    //结果Man也加上了baby</span><br><span class="line">    &#123;eays: 2, hand: 1, constructor: ƒ, baby: &#x27;sb&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用构造函数来创建对象，可以获得相同的属性值对象，但不是同一个对象，只需改成</span><br><span class="line">function Person ()  &#123;</span><br><span class="line">      this.eays = 2</span><br><span class="line">      this.hand = 1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">//应用</span><br><span class="line">Man.prototype = new Person</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型对象，实例对象的__proto__都可以指向其上一层的构造函数的__proto__，例如实例对象的__proto__可以找到他的构造函数，而构造函数的原型对象的__proto__指向上一级Object的prototype</p>
<h4 id="对象都有对象原型-proto"><a href="#对象都有对象原型-proto" class="headerlink" title="对象都有对象原型__proto__"></a>对象都有对象原型__proto__</h4><h3 id="原型链查找规则："><a href="#原型链查找规则：" class="headerlink" title="原型链查找规则："></a>原型链查找规则：</h3><p>先查找自身有没有，如果没有就查找他的原型对象，还是没有再往上查找object的原型对象，还是没有就为null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">instanceof 检测构造函数是否在这条原型链上</span><br><span class="line">    console.log(ldh instanceof Person)</span><br><span class="line">    console.log(ldh instanceof Object)</span><br><span class="line">    console.log(ldh instanceof Array)</span><br><span class="line">    console.log([1, 2, 3] instanceof Array)</span><br><span class="line">    console.log(Array instanceof Object)</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>箭头函数的妙用，此处必须使用箭头函数，使用fuction的话this指向的是<i>，使用箭头函数则指向我所需要的第一个this指向的标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.modalBox.querySelector(&#x27;i&#x27;).addEventListener(&#x27;click&#x27;,  () =&gt; &#123;</span><br><span class="line">//这个this指向我创建的标签</span><br><span class="line">        this.close() //这个指向&lt;i&gt;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
    </div>
</article>
        </main>
        <aside class="aside">
            <div class="close"></div>
            <section class="aside-section">
                
    <h1>Categories</h1>

    

            </section>
            <section class="aside-section">
                
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>


            </section>
            <section class="aside-section tag">
                
    <h1>Tags</h1>

    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li></ul>

            </section>
        </aside>
    </div>
</body>

</html>