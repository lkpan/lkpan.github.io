<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小满-vue3学习笔记</title>
      <link href="/2023/06/27/vue3/%E5%B0%8F%E6%BB%A1-vue3/"/>
      <url>/2023/06/27/vue3/%E5%B0%8F%E6%BB%A1-vue3/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest</span><br><span class="line">// 如果脚手架 </span><br><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><h1 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h1><p>public目录不会被编译</p><p>入口文件不是和vue2中的main.js而是使用idnex.html</p><p>插件volar，禁用vue2中的vetur</p><h2 id="执行过程-npm-run-dev"><a href="#执行过程-npm-run-dev" class="headerlink" title="执行过程 npm run dev"></a>执行过程 npm run dev</h2><p>首先到json文件中查找执行，然后再到模块中的bin中查找可执行的vite,如果没有的话就npm install -g 中查找 ，如果没有就报错</p><p>直接执行vite命令，不行</p><h2 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h2><p>虚拟dom就是通过js生成AST节点数</p><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>有key和没key</p><p>先判断type和key是否一致，如果一致的话会和原来的dom进行比较，如果一样的话就行复用，如果不一样就进行插入</p><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul><li>ref返回的其实是class类，读取&#x2F;修改需要先加个value</li><li>isRef判断是否ref对象</li></ul><h2 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr:readonly [x:number,y?:boolean] = [1,false] // 只读,问号表示可选</span><br></pre></td></tr></table></figure><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str = 6</span><br></pre></td></tr></table></figure><blockquote><p>ts可以自动推出简单的类型，因此可不用再设置</p></blockquote><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type s = number[] | string</span><br><span class="line">let v:s = &#x27;12f&#x27;</span><br></pre></td></tr></table></figure><p>和interface很想，但是无法想interface一样extends继承，进行合并，但是可以快速写出联合类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type num = 1 extends number ? 1 : 0</span><br><span class="line">extends在这表示包含</span><br></pre></td></tr></table></figure><h2 id="唯一值symbol"><a href="#唯一值symbol" class="headerlink" title="唯一值symbol"></a>唯一值symbol</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a1:symbol = Symbol(1)</span><br><span class="line">  let a2:symbol = Symbol(1)</span><br><span class="line">  console.log(a1==a2);</span><br><span class="line">  // 如果全局有注册这个key就直接拿来用，没有就注册</span><br><span class="line">  console.log(Symbol.for(&#x27;a1&#x27;)==Symbol.for(&#x27;a1&#x27;));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 通过Reflect.ownkeys(obj)获取symbol以及string类型的key</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>语法糖 for of，但是对象不能用，因为对象没有 <a href="">Symbol.iterator</a> 方法</p></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>还不知道传入的参数类型以及返回的结果类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test&lt;K,T&gt;(a:K,b:T):Array&lt;K | T&gt;&#123;</span><br><span class="line">  return [a,b]</span><br><span class="line">&#125;</span><br><span class="line">test(0,false)</span><br></pre></td></tr></table></figure><p>推断结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function test&lt;number, boolean&gt;(a: number, b: boolean): (number | boolean)[]</span><br></pre></td></tr></table></figure><h2 id="父子组件传参"><a href="#父子组件传参" class="headerlink" title="父子组件传参"></a>父子组件传参</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>父组件：<code>&lt;Layout :title=&#39;name&#39;&gt;&lt;/Layout&gt;</code></p><p>子组件接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const props = defineProps(&#123;</span><br><span class="line">   title:&#123;</span><br><span class="line">      type:String,</span><br><span class="line">      default:&#x27;默认值&#x27;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">withDefaults(defineProps&lt;&#123;</span><br><span class="line">  title: string;</span><br><span class="line">  arr: number[];</span><br><span class="line">&#125;&gt;(),&#123;</span><br><span class="line">   arr:()=&gt;[5646]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>第一种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const emit = defineEmits([&#x27;on-click&#x27;])</span><br><span class="line">const send = () =&gt; &#123;</span><br><span class="line">   emit(&#x27;on-click&#x27;,&#x27;传的值&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line">  (e:&#x27;on-click&#x27;,name:string):void</span><br><span class="line">&#125;&gt;()</span><br><span class="line">const send = () =&gt; &#123;</span><br><span class="line">   emit(&#x27;on-click&#x27;,&#x27;传的值&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态插槽"><a href="#动态插槽" class="headerlink" title="动态插槽"></a>动态插槽</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Dialog&gt;</span><br><span class="line">      &lt;template #[name]&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          我在这呢&#123;&#123;name&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/Dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import Dialog from &#x27;./components/Dialog.vue&#x27;</span><br><span class="line">const name = ref(&#x27;footer&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h2><p>可以通过控制<code>:include</code> 控制哪个组件需要设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;KeepAlive :include=&quot;[&#x27;A&#x27;]&quot;&gt;</span><br><span class="line">    &lt;A v-if=&quot;flag&quot;&gt;&lt;/A&gt;</span><br><span class="line">    &lt;B v-else&gt;&lt;/B&gt;</span><br><span class="line">  &lt;/KeepAlive&gt;</span><br></pre></td></tr></table></figure><p><code>:max=&quot;10&quot;</code> 可以限制数量，会把旧的去掉，保留最近活跃的</p><p>兄弟组件mitt</p><p>导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mitt -S</span><br></pre></td></tr></table></figure><p>使用</p><blockquote><p>A组件 发送</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const instance = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">const emitB = () =&gt; &#123;</span><br><span class="line">    instance?.proxy?.$Bus.emit(&#x27;on-click&#x27;,&#x27;mitt&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>B组件 接收</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;</span><br><span class="line">const instance = getCurrentInstance()</span><br><span class="line">instance?.proxy?.$Bus.on(&#x27;on-click&#x27;, (str:string) =&gt; &#123;</span><br><span class="line">    console.log(str);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="tsx"><a href="#tsx" class="headerlink" title="tsx"></a>tsx</h2><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            age: 23</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (&lt;div &gt;&#123;this.age&#125;&lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent,ref &#125; from &#x27;vue&#x27;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const flag = ref (false)</span><br><span class="line">        return () =&gt; (&lt;div v-show=&#123;flag.value&#125;&gt;标签bbb&lt;/div&gt;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>终于写完了项目前台</title>
      <link href="/2023/01/22/%E7%BB%88%E4%BA%8E%E5%86%99%E5%AE%8C%E4%BA%86%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%8F%B0/"/>
      <url>/2023/01/22/%E7%BB%88%E4%BA%8E%E5%86%99%E5%AE%8C%E4%BA%86%E9%A1%B9%E7%9B%AE%E5%89%8D%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>学了一段时间了，终于完成了一个小项目的前台，收获还是很大的，这两天过年也花了不少时间来做这个，也没有去玩，坚持就是胜利！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传到远端GitHub</title>
      <link href="/2023/01/16/%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%AB%AFGitHub/"/>
      <url>/2023/01/16/%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%AB%AFGitHub/</url>
      
        <content type="html"><![CDATA[<h1 id="未连接仓库时"><a href="#未连接仓库时" class="headerlink" title="未连接仓库时"></a>未连接仓库时</h1><h2 id="新建一个仓库"><a href="#新建一个仓库" class="headerlink" title="新建一个仓库"></a>新建一个仓库</h2><ol><li>选择为 public</li><li>若想设置成网站，名称末尾得加个 .github.io</li></ol><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><ul><li>在写好的代码根目录处，右键 gitBash</li></ul><blockquote><p>初始化仓库</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="设置用户名称及邮箱"><a href="#设置用户名称及邮箱" class="headerlink" title="设置用户名称及邮箱"></a>设置用户名称及邮箱</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br></pre></td></tr></table></figure><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>添加全部到暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h2 id="提交并备注信息"><a href="#提交并备注信息" class="headerlink" title="提交并备注信息"></a>提交并备注信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交信息&quot;</span><br></pre></td></tr></table></figure><h2 id="绑定仓库"><a href="#绑定仓库" class="headerlink" title="绑定仓库"></a>绑定仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://自己的仓库url地址</span><br></pre></td></tr></table></figure><h2 id="最后上传"><a href="#最后上传" class="headerlink" title="最后上传"></a>最后上传</h2><br/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><blockquote><p>需要修改上传只需要 git add . 添加到暂存区， 然后push提交上去即可</p></blockquote><br/><blockquote><p>目前这些操作不够全面，后续再添加更详细操作</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/30/Set%E6%B1%82%E4%BA%A4%E5%B9%B6%E5%B7%AE%E9%9B%86/"/>
      <url>/2022/11/30/Set%E6%B1%82%E4%BA%A4%E5%B9%B6%E5%B7%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>title: 上传到远端GitHub<br>date: 2022-01-0 21:22:09<br>tags:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [11, 22, 33, 44,555]</span><br><span class="line">const arr2 = [22,55,33, 77, 88]</span><br><span class="line">//并集</span><br><span class="line">const union = [...new Set([...arr1, ...arr2])]</span><br><span class="line">console.log(&#x27;并集&#x27;+union);</span><br><span class="line">//交集</span><br><span class="line">const cross = [...new Set([...arr1])].filter(item =&gt; arr2.includes(item))</span><br><span class="line">console.log(&#x27;交集&#x27;+cross);</span><br><span class="line">//差集</span><br><span class="line">const cross1 = [...new Set([...arr1])].filter(item =&gt; !arr2.includes(item))</span><br><span class="line">console.log(&#x27;交集&#x27;+cross1);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/26/giveup/firstday/"/>
      <url>/2022/11/26/giveup/firstday/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="zh"><head>    <meta charset="UTF-8">    <meta http-equiv="X-UA-Compatible" content="IE=edge">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>firstDayCode</title>    <style>body{  margin: 0;  padding: 0;}/* 內减模式 */* {    box-sizing: border-box;}/* 设置网页统一的字体大小、行高、字体系列相关属性 */body {  font: 16px/1.5 "Helvetica Neue", Helvetica, Arial, "Microsoft Yahei",    "Hiragino Sans GB", "Heiti SC", "WenQuanYi Micro Hei", sans-serif;  color: #333;}.container {    display: flex;    margin: 10vw;}.pic {    flex: 0.2;    text-align: center;    border-radius: 20%;    height: 80vh;    background-repeat: no-repeat;    background-size: cover;    transition: all 1s;    font-size: 2vw;}.pic:not(:last-child) {    margin-right: 2vw;}.active {    flex: 1;}    </style></head><body>    <div class="container">        <span class="pic active" style="background-image: url('https://cdn.yemek.com/mnresize/940/940/uploads/2015/09/humus-guncelleme-sunum-2.jpg')">FOOD</span>        <span class="pic" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F0%2F57b159759bf7d.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1671984843&t=568a3385c14d141a7af426fa84614495')">FOOD</span>        <span class="pic" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F0%2F57b56b519ab4e.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1671984843&t=2bcee084397bc65a62fa8ab5d4695700')">FOOD</span>        <span class="pic" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Flmg.jj20.com%2Fup%2Fallimg%2F811%2F0HQ4104127%2F140HQ04127-5-1200.jpg&refer=http%3A%2F%2Flmg.jj20.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1671984843&t=38ee8da12cdb65983b89e91ecf33d0b1')">FOOD</span>    </div>    <script>        let pics = document.querySelectorAll('.pic')        pics.forEach(element => {            element.addEventListener('click', function() {                removeActive()                element.classList.add('active')            })        })        function removeActive() {            pics.forEach(element => {                element.className = 'pic'            })        }    </script></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符、数组、对象 的数据处理</title>
      <link href="/2022/11/13/HTML%20CSS/%E5%AD%97%E7%AC%A6%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2022/11/13/HTML%20CSS/%E5%AD%97%E7%AC%A6%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h1><h4 id="indexof-x2F-lastIndexOf-最后一个"><a href="#indexof-x2F-lastIndexOf-最后一个" class="headerlink" title="indexof &#x2F;     lastIndexOf(最后一个)"></a>indexof &#x2F;     lastIndexOf(最后一个)</h4><p>判断一个字符第一次出现在某个字符串的索引,如果包含返回它的索引，如果不包含返回-1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abcde&#x27;;</span><br><span class="line">console.log(str.indexOf(&#x27;e&#x27;));   //4</span><br></pre></td></tr></table></figure><h4 id="substring-n-m"><a href="#substring-n-m" class="headerlink" title="substring(n,m)"></a>substring(n,m)</h4><p>从索引n开始，截取m个字符，将截取的字符返回，对原字符串没有任何改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abcde&#x27;</span><br><span class="line">var bc = str.substring(1,3);</span><br><span class="line">console.log(bc);  //&quot;bc&quot;</span><br></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abcde&#x27;</span><br><span class="line">var a = str.split(&#x27;&#x27;);</span><br><span class="line">console.log(a);  //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br></pre></td></tr></table></figure><h4 id="replace-‘a’-1"><a href="#replace-‘a’-1" class="headerlink" title="replace(‘a’,1)"></a>replace(‘a’,1)</h4><p>替换指定字符，返回替换后新的字符串，对原有字符串有改变(第一个参数可以是正则表达式) 只能替换一次 ，配合正则式修饰符g使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&#x27;aaaaee&#x27;;</span><br><span class="line">var reg=/a/g;</span><br><span class="line">console.log(str.replace(reg,1));   //&quot;1111ee&quot;</span><br></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。把找到的字符放在数组里，返回一个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;aaaa3ebbd33&#x27;;</span><br><span class="line">var reg = /a/g;</span><br><span class="line">console.log(str.match(reg));  //[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure><h1 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h1><h4 id="toString-、toLocaleString-、valueOf-方法。其中toString-方法会返回由数组中每个值的字符串拼接而成的一个以逗号分隔的字符串，而调用valueOf-返回的还是数组"><a href="#toString-、toLocaleString-、valueOf-方法。其中toString-方法会返回由数组中每个值的字符串拼接而成的一个以逗号分隔的字符串，而调用valueOf-返回的还是数组" class="headerlink" title="toString()、toLocaleString()、valueOf()方法。其中toString()方法会返回由数组中每个值的字符串拼接而成的一个以逗号分隔的字符串，而调用valueOf()返回的还是数组"></a>toString()、toLocaleString()、valueOf()方法。其中toString()方法会返回由数组中每个值的字符串拼接而成的一个以逗号分隔的字符串，而调用valueOf()返回的还是数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let newList = [&#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;];</span><br><span class="line"> </span><br><span class="line">newList.toString() // &quot;orange,apple,banana&quot;</span><br><span class="line">newList.valueOf() // [&quot;orange&quot;, &quot;apple&quot;, &quot;banana&quot;]</span><br><span class="line">newList.toLocaleString() // &quot;orange,apple,banana&quot;</span><br><span class="line"> </span><br><span class="line">console.log(newList.toString()) // &quot;orange,apple,banana&quot;</span><br><span class="line">alert(newList.valueOf()) // &quot;orange,apple,banana&quot;</span><br><span class="line">console.log(newList.toLocaleString()) // &quot;orange,apple,banana&quot;</span><br></pre></td></tr></table></figure><h4 id="join-方法可以使用不同的分隔符"><a href="#join-方法可以使用不同的分隔符" class="headerlink" title="join() 方法可以使用不同的分隔符"></a>join() 方法可以使用不同的分隔符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let newList = [&#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;];</span><br><span class="line">console.log(newList.join(&#x27;|&#x27;)) // &quot;orange|apple|banana&quot;</span><br></pre></td></tr></table></figure><h4 id="Array-from-方法用于将伪数组转为真正的数组"><a href="#Array-from-方法用于将伪数组转为真正的数组" class="headerlink" title="Array.from 方法用于将伪数组转为真正的数组"></a>Array.from 方法用于将伪数组转为真正的数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &#x27;0&#x27;: &#x27;a&#x27;,</span><br><span class="line">    &#x27;1&#x27;: &#x27;b&#x27;,</span><br><span class="line">    &#x27;2&#x27;: &#x27;c&#x27;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"> </span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"> </span><br><span class="line">Array.from([1, 2, 3])</span><br><span class="line">// [1, 2, 3] 如果参数是一个真数组，会返回一个一摸一样的新数组</span><br></pre></td></tr></table></figure><h4 id="push-可以接受任意数量的参数，然后返回修改后的数组的长度。"><a href="#push-可以接受任意数量的参数，然后返回修改后的数组的长度。" class="headerlink" title="push 可以接受任意数量的参数，然后返回修改后的数组的长度。"></a>push 可以接受任意数量的参数，然后返回修改后的数组的长度。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line"> </span><br><span class="line">console.log(arr.push(5)); // 5</span><br><span class="line">console.log(arr.push([1, 2])); // 6</span><br><span class="line">console.log(arr); // [ 1, 2, 3, 4, 5, [ 1, 2 ] ]</span><br></pre></td></tr></table></figure><h4 id="pop-可以从数组的末尾移除最后一项，减少数组的长度，返回删除项"><a href="#pop-可以从数组的末尾移除最后一项，减少数组的长度，返回删除项" class="headerlink" title="pop  可以从数组的末尾移除最后一项，减少数组的长度，返回删除项"></a>pop  可以从数组的末尾移除最后一项，减少数组的长度，返回删除项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line">console.log(arr.pop()); // 4</span><br><span class="line">console.log(arr); // [1, 2, 3, ]</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Great_Zhou/article/details/112234716">更多更全的数组处理方法</a></p><h1 id="对象处理方法"><a href="#对象处理方法" class="headerlink" title="对象处理方法"></a>对象处理方法</h1><p><a href="https://blog.csdn.net/weixin_44247511/article/details/120881680">对象处理方法</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript进阶第二天</title>
      <link href="/2022/01/07/JS%E9%AB%98%E7%BA%A7/%E7%AC%AC%E4%B8%89%E5%A4%A9%E8%BF%9B%E9%98%B6JS/"/>
      <url>/2022/01/07/JS%E9%AB%98%E7%BA%A7/%E7%AC%AC%E4%B8%89%E5%A4%A9%E8%BF%9B%E9%98%B6JS/</url>
      
        <content type="html"><![CDATA[<h2 id="每个构造函数都有一个原型对象"><a href="#每个构造函数都有一个原型对象" class="headerlink" title="每个构造函数都有一个原型对象"></a>每个构造函数都有一个原型对象</h2><p>原型可以共享一个方法，把不变的方法写到prototype对象上</p><h2 id="构造函数this指向问题"><a href="#构造函数this指向问题" class="headerlink" title="构造函数this指向问题"></a>构造函数this指向问题</h2><pre><code>let thatfunction Star(uname) &#123;that = thisconsole.log(this)this.uname = uname    &#125;    //结果为（that === ldh）    //Star &#123;uname: &#39;刘德华&#39;&#125;  里面this结果</code></pre><p>原型实例对象里面的this指向的也是其调用者</p><h2 id="原型对象-prototype"><a href="#原型对象-prototype" class="headerlink" title="原型对象  .prototype"></a>原型对象  .prototype</h2><p>是个对象，可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</p><h2 id="constructor作用"><a href="#constructor作用" class="headerlink" title="constructor作用"></a>constructor作用</h2><p>因为使用直接&#x3D; 的形式将会使其找不到原先的构造函数，需要construtor重新指向原来的构造函数</p><pre><code>实例对象.constructor指向构造函数StarWoman.prototype.constructor = Woman</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Star.prototype = &#123;</span><br><span class="line">// 从新指回创造这个原型对象的 构造函数</span><br><span class="line">      constructor: Star,</span><br><span class="line">      sing: function () &#123;</span><br><span class="line">        console.log(&#x27;唱歌&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">      dance: function () &#123;</span><br><span class="line">        console.log(&#x27;跳舞&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="对象模型-proto"><a href="#对象模型-proto" class="headerlink" title="对象模型__proto__"></a>对象模型__proto__</h2><pre><code>__proto__与[[prototype]]一个意思function Star (uname) &#123;      this.name = uname    &#125;    let sb = new Star(&#39;sb&#39;)    console.log(sb.__proto__ === Star.prototype);//true    //Star：构造函数，sb实例对象，sb.__proto__ 以及Star.prototype都指向Star的原型对象</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A as 构造函数</span><br><span class="line">A-&gt;&gt;C: new一个再 .prototype</span><br><span class="line">participant B as 实例对象</span><br><span class="line">participant C as 原型对象</span><br><span class="line">A-&gt;&gt;B: new一个就可以产生实例对象</span><br><span class="line">B-&gt;&gt;C: 实例对象.__proto__</span><br><span class="line">B-&gt;&gt;A: 实例对象.__proto__.constructor</span><br><span class="line">C-&gt;&gt;A: 原型即 prototype.constructor</span><br></pre></td></tr></table></figure><h2 id="原型继承-公共属性"><a href="#原型继承-公共属性" class="headerlink" title="原型继承 公共属性"></a>原型继承 公共属性</h2><p>需要公共属性一致，但不是同一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Person = &#123;</span><br><span class="line">      eays : 2,</span><br><span class="line">      hand : 1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function Woman() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Woman.prototype = Person</span><br><span class="line">    Woman.prototype.constructor = Woman</span><br><span class="line">    Woman.prototype.baby = &#x27;sb&#x27;</span><br><span class="line">    console.log(Woman.prototype);</span><br><span class="line">    </span><br><span class="line">    function Man () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Man.prototype = Person</span><br><span class="line">    Man.prototype.constructor = Man</span><br><span class="line">    console.log(Man.prototype);</span><br><span class="line">    </span><br><span class="line">    //结果Man也加上了baby</span><br><span class="line">    &#123;eays: 2, hand: 1, constructor: ƒ, baby: &#x27;sb&#x27;&#125;</span><br></pre></td></tr></table></figure><h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用构造函数来创建对象，可以获得相同的属性值对象，但不是同一个对象，只需改成</span><br><span class="line">function Person ()  &#123;</span><br><span class="line">      this.eays = 2</span><br><span class="line">      this.hand = 1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">//应用</span><br><span class="line">Man.prototype = new Person</span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型对象，实例对象的__proto__都可以指向其上一层的构造函数的__proto__，例如实例对象的__proto__可以找到他的构造函数，而构造函数的原型对象的__proto__指向上一级Object的prototype</p><h4 id="对象都有对象原型-proto"><a href="#对象都有对象原型-proto" class="headerlink" title="对象都有对象原型__proto__"></a>对象都有对象原型__proto__</h4><h3 id="原型链查找规则："><a href="#原型链查找规则：" class="headerlink" title="原型链查找规则："></a>原型链查找规则：</h3><p>先查找自身有没有，如果没有就查找他的原型对象，还是没有再往上查找object的原型对象，还是没有就为null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">instanceof 检测构造函数是否在这条原型链上</span><br><span class="line">    console.log(ldh instanceof Person)</span><br><span class="line">    console.log(ldh instanceof Object)</span><br><span class="line">    console.log(ldh instanceof Array)</span><br><span class="line">    console.log([1, 2, 3] instanceof Array)</span><br><span class="line">    console.log(Array instanceof Object)</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>箭头函数的妙用，此处必须使用箭头函数，使用fuction的话this指向的是<i>，使用箭头函数则指向我所需要的第一个this指向的标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.modalBox.querySelector(&#x27;i&#x27;).addEventListener(&#x27;click&#x27;,  () =&gt; &#123;</span><br><span class="line">//这个this指向我创建的标签</span><br><span class="line">        this.close() //这个指向&lt;i&gt;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
